-- Tighten default privileges and introduce dedicated session storage tables
-- Generated by Codex assistant: adjust privileges, policies, and storage into secure defaults

--------------------------------------------------------------------------------
-- Revoke overly broad privileges granted to anon/authenticated roles
--------------------------------------------------------------------------------
REVOKE ALL ON SCHEMA public FROM anon;
REVOKE ALL ON SCHEMA public FROM authenticated;
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM anon;
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM authenticated;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA public FROM anon;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA public FROM authenticated;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA public FROM anon;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA public FROM authenticated;

-- Restore minimal required schema usage
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;

--------------------------------------------------------------------------------
-- Granular grants per table (aligning with existing application usage)
--------------------------------------------------------------------------------
GRANT SELECT, INSERT, UPDATE ON public.review_requests TO authenticated;
GRANT SELECT, INSERT, UPDATE ON public.profiles TO authenticated;
GRANT SELECT ON public.user_roles TO authenticated;
GRANT SELECT ON public.subscription_plans TO authenticated;
GRANT SELECT ON public.subscriptions TO authenticated;
GRANT SELECT ON public.business_units TO authenticated;
GRANT SELECT ON public.licensees TO authenticated;
GRANT SELECT, INSERT ON public.analytics TO authenticated;

-- No direct table access is granted to the anon role; unauthenticated access must
-- flow through controlled RPCs or edge functions.

--------------------------------------------------------------------------------
-- Ensure future objects do not inherit ALL privileges by default
--------------------------------------------------------------------------------
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON TABLES FROM anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON TABLES FROM authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON SEQUENCES FROM anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON SEQUENCES FROM authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM authenticated;

--------------------------------------------------------------------------------
-- Session storage schema for secure, server-managed persistence
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.session_records (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    session_uuid uuid NOT NULL UNIQUE,
    payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.chat_messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    session_uuid uuid NOT NULL REFERENCES public.session_records (session_uuid) ON DELETE CASCADE,
    sender text NOT NULL CHECK (sender IN ('user', 'agent')),
    content text NOT NULL,
    metadata jsonb,
    created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.profiles
    ADD COLUMN IF NOT EXISTS provider_mode_enabled boolean NOT NULL DEFAULT false;

CREATE TABLE IF NOT EXISTS public.providers (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS providers_user_id_name_key
    ON public.providers (user_id, name);

-- Keep timestamps fresh
DROP TRIGGER IF EXISTS update_session_records_updated_at ON public.session_records;
CREATE TRIGGER update_session_records_updated_at
    BEFORE UPDATE ON public.session_records
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

--------------------------------------------------------------------------------
-- Row Level Security policies for the new tables
--------------------------------------------------------------------------------
ALTER TABLE public.session_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.providers ENABLE ROW LEVEL SECURITY;

-- Ensure profile access policies are enforced with explicit checks
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile"
    ON public.profiles
    FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can update their own profile"
    ON public.profiles
    FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile"
    ON public.profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can view their providers" ON public.providers;
CREATE POLICY "Users can view their providers"
    ON public.providers
    FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can manage their providers" ON public.providers;
CREATE POLICY "Users can manage their providers"
    ON public.providers
    FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their providers" ON public.providers;
CREATE POLICY "Users can update their providers"
    ON public.providers
    FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their providers" ON public.providers;
CREATE POLICY "Users can delete their providers"
    ON public.providers
    FOR DELETE USING (auth.uid() = user_id);

-- session_records policies: users manage only their own rows
DROP POLICY IF EXISTS "Users can access their own session records" ON public.session_records;
CREATE POLICY "Users can access their own session records"
    ON public.session_records
    FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own session records" ON public.session_records;
CREATE POLICY "Users can insert their own session records"
    ON public.session_records
    FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own session records" ON public.session_records;
CREATE POLICY "Users can update their own session records"
    ON public.session_records
    FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own session records" ON public.session_records;
CREATE POLICY "Users can delete their own session records"
    ON public.session_records
    FOR DELETE USING (auth.uid() = user_id);

-- chat_messages policies: derive ownership via the parent session record
DROP POLICY IF EXISTS "Users can read messages for owned sessions" ON public.chat_messages;
CREATE POLICY "Users can read messages for owned sessions"
    ON public.chat_messages
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.session_records sr
            WHERE sr.session_uuid = chat_messages.session_uuid
              AND sr.user_id = auth.uid()
        )
    );

DROP POLICY IF EXISTS "Users can insert messages for owned sessions" ON public.chat_messages;
CREATE POLICY "Users can insert messages for owned sessions"
    ON public.chat_messages
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.session_records sr
            WHERE sr.session_uuid = chat_messages.session_uuid
              AND sr.user_id = auth.uid()
        )
    );

DROP POLICY IF EXISTS "Users can delete messages for owned sessions" ON public.chat_messages;
CREATE POLICY "Users can delete messages for owned sessions"
    ON public.chat_messages
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM public.session_records sr
            WHERE sr.session_uuid = chat_messages.session_uuid
              AND sr.user_id = auth.uid()
        )
    );

--------------------------------------------------------------------------------
-- Grants for the new tables (aligned with policies)
--------------------------------------------------------------------------------
GRANT SELECT, INSERT, UPDATE, DELETE ON public.session_records TO authenticated;
GRANT SELECT, INSERT, DELETE ON public.chat_messages TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.providers TO authenticated;
